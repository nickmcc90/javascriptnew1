<!DOCTYPE html>
<html>
  <head>
    <title>Advanced Functions</title>
    <style>

    </style>
  </head>
  <body>
    <button class="js-button" onclick="

    ">Click</button> <!--This button relates to the comments near the bottom.-->
    <script>
      function greeting() {
        console.log('hello');
      }
      greeting();

      // We can save functions inside variables.

      const function1 = function greeting() {
        console.log('hello2');
      }

      console.log(function1) // shows the stuff inside this variable.
      console.log(typeof function1) // its a function.
      function1(); // this'll run the function like normal even though it's a variable.
    
      
      // If you've noticed, we've been able to call functions before they are written in the
      // code. This is due to hoisting. However, when we save the function in a variable like
      // above, hoisting does not apply.
      
      const object1 = {
        num: 2,
        fun: function() {       //There's no need for a function name here.
          console.log('hello3');
        }
      }
      object1.fun();      


      // We can pass a function into a function.

      function run(param) {
        param();          //param stores a function inside of it. We can call this function using param.
      }
      run(function() {
        console.log('hello4');
      });

      // setTimeout() allows us to run a function in the future...

      setTimeout(function() {
        console.log('timeout');
      }, 3000); // first arg, a function we wanna run in the function. second arg, how long to wait before running the function in ms.
      console.log('next line');

      // setTimeout() is asynchoronus code. It won't wait for a line to finish before going to the next line.
      // Synchoronous code is code that will wait until a line is done before going on to the next line. We've
      // only written synchoronous code so far.

      // setInterval(function() {
      //   console.log('interval');
      // }, 3000);  // same parameters as setTimeout(). setInterval() keeps running the function over and over in the intervals that you give it.
    
    
      // There is another way to loop through arrays.

      [
        'make dinner',
        'wash dishes',
        'watch youtube'
      ].forEach(function(value, index) {   // Loops through array, based on this function that we pass through. Second arg is the index.
        if(value === 'wash dishes') {
          return;
        }
        
        console.log(index);
        console.log(value);     // In forEach() statements, there is no continue. But we can achieve the same thing with a return statement.
      });


      // Now we are going to learn a shorter way to write functions, called arrow functions.
    
      const arrowFunction = (param, param2) => {
        console.log('hello');         // this works the same as a normal function.
        return 5;
      };
      arrowFunction();

      const regularFunction = function(param, param2) {    // this is a normal function
        console.log('hello');
        return 5;
      };

      // What are the differences?

      const oneParam = param => {
        console.log(param + 1)      // When an arrow function only has only parameter, the parenthesis are not needed.
      };
      oneParam(2);

      const oneLine = () => {
        return 2 + 3;           // When we only have one line of code in the arrow function, it can be rewritten without curly brackets, or return statement,
                                // like....
      };

      const oneeLine = () => 2 + 3;
      console.log(oneeLine());

      //rewritting a .forEach to be like an arrow function is like...

      [1, 2, 3.].forEach((value, index) => {
        if(value === 2) {
          return;
        }
        console.log(value);
      })

      // It's good practice when passing a function into another function to use an arrow function for the inside function. It's easier to read.
      // It's preference to use arrow or regular, but regular does have hoisting.
      // Hoisting, doesn't matter where the function is written, it can be called
      // anywhere.


      // We can use arrow functions inside an object.

      const object2 = {
        method: () => {
                        // Arrow function.
        },
        method() {
                        // This shorthand is easier than an arrow func.
        }
      }


      // ADD EVENT LISTENER... in order to use, have the buttonElement saved in javascript with document.query stuff


      const buttonElement = document.querySelector('.js-button');
      buttonElement.addEventListener('click', () => {
        console.log('click');
      }) // first arg is the event, second arg is a function we want to run.
        // Clicking the button will display click in the console.
        // This code does the same thing as the 'onclick' attribute.

        // addEventListener has some advantages over onclick however. We can
        // add multiple event listeners.

        buttonElement.addEventListener('click', () => {
        console.log('click2');
      }) 

      // we can remove event listeners too.

      const yes = () => {
        console.log('yes')
      }
      buttonElement.addEventListener('click', yes);
      buttonElement.removeEventListener('click', yes);

      // best practice is to use addEventListener() because of these advantages.
    
      

      // We are gonna learn two more array methods, filter() and map().
    
      [1, -3, 5].filter((value, index) => {   // .filter() creates a new array based on the function passed through.
        // if(value > 0) {                   // If the return is true, it puts the value in the array.
        //   return true;
        // } else {
        //   return false;
        // }
        return value >= 0;    // simplified version of above code.
      });

      // filter returns true and false values only.



      [1, 1, 3].map((value, index) => {     // map is the same as filter(), but the returns can be values.
        return value * 2;
      });
    
      [1, 1, 3].map(value => value * 2);    // condensed arrow function shortcuts.
    
    
    </script>
  </body>
</html>